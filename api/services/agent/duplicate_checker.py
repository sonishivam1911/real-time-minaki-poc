"""
Service to prevent duplicate product names by checking existing Shopify products
and generating unique alternatives.
"""

import logging
import random
from typing import List, Optional, Set
from services.shopify.product import ShopifyProductService

logger = logging.getLogger("Duplicate Name Checker")


class DuplicateNameChecker:
    """
    Service to ensure generated product names are unique across Shopify store.
    """
    
    def __init__(self, shopify_service: Optional[ShopifyProductService] = None):
        self.shopify_service = shopify_service or ShopifyProductService()
        self._existing_titles_cache: Set[str] = set()
        self._cache_loaded = False
    
    def _load_existing_titles_cache(self) -> None:
        """
        Load existing product titles from Shopify to cache.
        Only loads once per session for performance.
        """
        if self._cache_loaded:
            return
        
        try:
            logger.info("Loading existing product titles from Shopify...")
            
            # Query for all active products (titles only for efficiency)
            query = """
            query getProductTitles($first: Int!, $after: String) {
                products(first: $first, after: $after, query: "status:active") {
                    edges {
                        node {
                            id
                            title
                        }
                    }
                    pageInfo {
                        hasNextPage
                        endCursor
                    }
                }
            }
            """
            
            has_next_page = True
            cursor = None
            total_products = 0
            
            while has_next_page:
                variables = {"first": 250}
                if cursor:
                    variables["after"] = cursor
                
                result = self.shopify_service.client.execute_query(query, variables)
                
                if not result.get("data", {}).get("products"):
                    break
                
                products = result["data"]["products"]
                edges = products.get("edges", [])
                
                # Extract titles and add to cache
                for edge in edges:
                    title = edge["node"].get("title", "").strip()
                    if title:
                        self._existing_titles_cache.add(title.lower())
                
                total_products += len(edges)
                
                # Check for next page
                page_info = products.get("pageInfo", {})
                has_next_page = page_info.get("hasNextPage", False)
                cursor = page_info.get("endCursor")
            
            self._cache_loaded = True
            logger.info(f"Loaded {total_products} product titles into cache")
            
        except Exception as e:
            logger.error(f"Failed to load existing titles: {str(e)}")
            # Continue without cache - will be less efficient but still functional
            self._cache_loaded = False
    
    def check_and_fix_duplicate(self, proposed_title: str) -> str:
        """
        Check if proposed title is duplicate and generate unique alternative if needed.
        
        Args:
            proposed_title: The title generated by the LLM
            
        Returns:
            Unique title (either original or modified)
        """
        if not proposed_title or not proposed_title.strip():
            return self._generate_fallback_name()
        
        # Load cache if not already done
        self._load_existing_titles_cache()
        
        original_title = proposed_title.strip()
        
        # Check if original title is unique
        if not self._is_duplicate(original_title):
            return original_title
        
        logger.warning(f"Duplicate title detected: {original_title}")
        
        # Generate unique alternative
        unique_title = self._generate_unique_variant(original_title)
        logger.info(f"Generated unique alternative: {unique_title}")
        
        return unique_title
    
    def _is_duplicate(self, title: str) -> bool:
        """
        Check if title exists in cache or Shopify store.
        
        Args:
            title: Title to check
            
        Returns:
            True if duplicate found
        """
        title_lower = title.lower()
        
        # Check cache first (fast)
        if self._cache_loaded and title_lower in self._existing_titles_cache:
            return True
        
        # If cache not loaded or not found in cache, check Shopify directly
        try:
            # Search for exact title match
            query_filter = f'title:"{title}"'
            result = self.shopify_service.get_products(
                first=5,
                query_filter=query_filter
            )
            
            products = result.get("data", {}).get("products", {}).get("edges", [])
            
            # Check for exact matches
            for edge in products:
                existing_title = edge["node"].get("title", "").strip()
                if existing_title.lower() == title_lower:
                    # Add to cache for future checks
                    if self._cache_loaded:
                        self._existing_titles_cache.add(title_lower)
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Error checking duplicate for '{title}': {str(e)}")
            # Assume it's unique if we can't check (better than blocking)
            return False
    
    def _generate_unique_variant(self, original_title: str) -> str:
        """
        Generate unique variants of the original title.
        
        Args:
            original_title: The duplicate title
            
        Returns:
            Unique variant
        """
        base_title = original_title
        
        # Remove "Jewellery Set" or "Set" suffix for modification
        if base_title.endswith(" Jewellery Set"):
            base_name = base_title[:-14]  # Remove " Jewellery Set"
            suffix = " Jewellery Set"
        elif base_title.endswith(" Set"):
            base_name = base_title[:-4]   # Remove " Set"
            suffix = " Set"
        else:
            base_name = base_title
            suffix = ""
        
        # Strategy 1: Add elegant variations
        elegant_variations = [
            f"{base_name} Luxe{suffix}",
            f"{base_name} Elite{suffix}",
            f"{base_name} Prima{suffix}",
            f"{base_name} Royal{suffix}",
            f"{base_name} Grand{suffix}",
            f"{base_name} Regal{suffix}",
            f"{base_name} Noble{suffix}",
            f"{base_name} Divine{suffix}",
            f"{base_name} Radiant{suffix}",
            f"{base_name} Brilliant{suffix}"
        ]
        
        # Strategy 2: Add Roman numerals
        roman_variations = [
            f"{base_name} II{suffix}",
            f"{base_name} III{suffix}",
            f"{base_name} IV{suffix}",
            f"{base_name} V{suffix}"
        ]
        
        # Strategy 3: Add descriptive suffixes
        descriptive_variations = [
            f"{base_name} Collection{suffix}",
            f"{base_name} Series{suffix}",
            f"{base_name} Heritage{suffix}",
            f"{base_name} Legacy{suffix}",
            f"{base_name} Signature{suffix}"
        ]
        
        # Try variations in order of preference
        all_variations = elegant_variations + roman_variations + descriptive_variations
        
        for variant in all_variations:
            if not self._is_duplicate(variant):
                return variant
        
        # If all variations are taken, use timestamp-based fallback
        import time
        timestamp_suffix = str(int(time.time()))[-4:]  # Last 4 digits of timestamp
        fallback_title = f"{base_name} {timestamp_suffix}{suffix}"
        
        return fallback_title
    
    def _generate_fallback_name(self) -> str:
        """
        Generate a completely new name if the original is invalid.
        
        Returns:
            Fallback jewelry set name
        """
        elegant_names = [
            "Serenity", "Harmony", "Grace", "Elegance", "Radiance",
            "Brilliance", "Splendor", "Majesty", "Celestial", "Aurora",
            "Lumina", "Crystalline", "Ethereal", "Mystique", "Enchanted"
        ]
        
        base_name = random.choice(elegant_names)
        
        # Ensure uniqueness
        for i in range(100):  # Max 100 attempts
            if i == 0:
                candidate = f"{base_name} Jewellery Set"
            else:
                candidate = f"{base_name} {i+1} Jewellery Set"
            
            if not self._is_duplicate(candidate):
                return candidate
        
        # Ultimate fallback with timestamp
        import time
        timestamp = str(int(time.time()))[-6:]
        return f"Exclusive {timestamp} Jewellery Set"
    
    def batch_check_and_fix_duplicates(self, titles: List[str]) -> List[str]:
        """
        Check and fix multiple titles for duplicates.
        
        Args:
            titles: List of proposed titles
            
        Returns:
            List of unique titles
        """
        unique_titles = []
        used_titles = set()
        
        for title in titles:
            # Check against both existing store titles and titles in current batch
            unique_title = self.check_and_fix_duplicate(title)
            
            # Ensure uniqueness within the current batch as well
            attempt_count = 0
            while unique_title.lower() in used_titles and attempt_count < 10:
                unique_title = self._generate_unique_variant(unique_title)
                attempt_count += 1
            
            unique_titles.append(unique_title)
            used_titles.add(unique_title.lower())
        
        return unique_titles
    
    def check_for_duplicates(self, title: str) -> bool:
        """
        Check if title is a duplicate (method expected by LangGraph workflow)
        
        Args:
            title: Title to check
            
        Returns:
            True if duplicate found
        """
        return self._is_duplicate(title)
    
    def generate_unique_title(self, base_title: str, visual_context: Optional[dict] = None) -> str:
        """
        Generate unique title using visual context (method expected by LangGraph workflow)
        
        Args:
            base_title: The duplicate title
            visual_context: Visual analysis data to inform variations
            
        Returns:
            Unique variant
        """
        # Use visual context to create more appropriate variations
        if visual_context and visual_context.get('analysis'):
            analysis = visual_context['analysis']
            size_scale = analysis.get('size_scale', 'medium')
            complexity = analysis.get('complexity', 'moderate')
            style = analysis.get('design_style', 'classic')
            
            # Create contextually appropriate variations based on visual analysis
            return self._generate_contextual_variant(base_title, size_scale, complexity, style)
        else:
            # Fallback to standard variation generation
            return self._generate_unique_variant(base_title)
    
    def _generate_contextual_variant(self, original_title: str, size_scale: str, complexity: str, style: str) -> str:
        """
        Generate unique variants based on visual context
        
        Args:
            original_title: The duplicate title
            size_scale: Visual scale (delicate/medium/statement)
            complexity: Design complexity (simple/moderate/elaborate)
            style: Design style (traditional/modern/ethnic/fusion)
            
        Returns:
            Contextually appropriate unique variant
        """
        base_title = original_title
        
        # Remove "Jewellery Set" or "Set" suffix for modification
        if base_title.endswith(" Jewellery Set"):
            base_name = base_title[:-14]
            suffix = " Jewellery Set"
        elif base_title.endswith(" Set"):
            base_name = base_title[:-4]
            suffix = " Set"
        else:
            base_name = base_title
            suffix = ""
        
        # Generate variations based on visual characteristics
        variations = []
        
        # Size-based variations
        if size_scale == "delicate":
            variations.extend([
                f"{base_name} Petite{suffix}",
                f"{base_name} Dainty{suffix}",
                f"{base_name} Fine{suffix}",
                f"{base_name} Subtle{suffix}"
            ])
        elif size_scale == "statement":
            variations.extend([
                f"{base_name} Grand{suffix}",
                f"{base_name} Majestic{suffix}",
                f"{base_name} Imperial{suffix}",
                f"{base_name} Regal{suffix}"
            ])
        else:  # medium
            variations.extend([
                f"{base_name} Classic{suffix}",
                f"{base_name} Elegant{suffix}",
                f"{base_name} Refined{suffix}"
            ])
        
        # Complexity-based variations
        if complexity == "elaborate":
            variations.extend([
                f"{base_name} Ornate{suffix}",
                f"{base_name} Intricate{suffix}",
                f"{base_name} Detailed{suffix}"
            ])
        elif complexity == "simple":
            variations.extend([
                f"{base_name} Pure{suffix}",
                f"{base_name} Minimal{suffix}",
                f"{base_name} Clean{suffix}"
            ])
        
        # Style-based variations
        if style == "traditional":
            variations.extend([
                f"{base_name} Heritage{suffix}",
                f"{base_name} Legacy{suffix}",
                f"{base_name} Classic{suffix}"
            ])
        elif style == "modern":
            variations.extend([
                f"{base_name} Contemporary{suffix}",
                f"{base_name} Avant{suffix}",
                f"{base_name} Neo{suffix}"
            ])
        
        # Try contextual variations first
        for variant in variations:
            if not self._is_duplicate(variant):
                return variant
        
        # Fallback to standard variations if contextual ones are taken
        return self._generate_unique_variant(original_title)